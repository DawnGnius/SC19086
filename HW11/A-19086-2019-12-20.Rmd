---
title: "Homework 11"
author: "By 19086"
date: "`r Sys.Date()`"
output: 
  html_document:
    # css: style.css
---

```{r setup, include=FALSE, warning=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1222)
```
## Question AR2
1. You have already written an R function for Exercise 9.4 (page
277, Statistical Computing with R). Rewrite an Rcpp function
for the same task.

2. Compare the generated random numbers by the two functions
using qqplot.

3. Campare the computation time of the two functions with
microbenchmark.

4. Comments your results.


#### Exercise 9.4
Implement a random walk Metropolis sampler for generating the standard Laplace distribution (see Exercise 3.2). 
For the increment, simulate from a normal distribution. 
Compare the chains generated when different variances are used for the proposal distribution. 
Also, compute the acceptance rates of each chain.

## Answer AR2

### Task 1

Implement the random walk version of the Metropolis sampler to generate the target distribution standard Laplace $l$, using the proposal distribution $Normal(X_t, \sigma^2)$. 
In order to see the effect of different choices of variance of the proposal distribution, try repeating the simulation with different choices of $\sigma$.

The standard Laplace distribution $l$ is $f(x)=\frac{1}{2}e^{-|x|} \propto e^{-|x|}$, for $x\in\mathbb{R}$. So
\begin{equation}
  r(x_t, y) = \frac{f(Y)}{f(X_t)} = \frac{e^{-|y|}}{e^{-|x_t|}}
\end{equation}

#### R version
In this simulation below, the Laplace densities in $r(x_{i-1}, y)$ will be computed by *dlaplace* as following
```{r}
dlaplace <- function(x) exp(-abs(x))
```
Also, it can be implemented by *dlaplace* function in package *rmutil*.

Then $y$ is accepted or rejected and $X_i$ generated by 

```{r, eval=FALSE}
if (u[i] <= dt(y, n) / dt(x[i-1], n))
  x[i] <- y
else
  x[i] <- x[i-1]
```

These steps are combined into a function to generate the chain, given the parameters $n$ and $\sigma$, initial value $X_0$, and the length of the chain, $N$. 
```{r}
rw.Metropolis <- function(sigma, x0, N) {
  x <- numeric(N)
  x[1] <- x0
  u <- runif(N)
  k <- 0
  for (i in 2:N) {
    y <- rnorm(1, x[i-1], sigma)
    if (u[i] <= (exp(abs(x[i-1]) - abs(y))))
      x[i] <- y else {
      x[i] <- x[i-1]
      k <- k + 1
    }
  }
  return(list(x=x, k=k))
}
```

#### Rcpp version

This is the cpp code. 

Note that, NumericVector should to convert to a double using [0]. 
```{c, eval=FALSE}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
List rw_Metropolis(double sigma, double x0, int N) {
    NumericVector x(N);
    x[0] = x0;
    Function myrunif("runif");
    Function myrnorm("rnorm");
    NumericVector u = myrunif(Named("n") = N);
    int k = 0;
    for (int i=1; i<N; i++) {
        NumericVector y = myrnorm(Named("n")=1, Named("mean")=x[i-1], Named("sd")=sigma);
        if (u[i] <= (exp(abs(x[i-1]) - abs(y[0])))) {
            x[i] = y[0];
        } else {
            x[i] = x[i-1];
            k++;
        }
    }
    return List::create(Named("x")=x, Named("k")=k);
}
```

This is r code, using rcpp to call the cpp code above.
```{r}
library(Rcpp) # Attach R package "Rcpp"

# Define function in rw_Metropolis.cpp
sourceCpp("./rw_Metropolis.cpp")

# data preparation, setting 1
N <- 2000
sigma <- c(.05, .5, 2, 16)

x0 <- 25
rw1.cpp <- rw_Metropolis(sigma[1], x0, N)
rw2.cpp <- rw_Metropolis(sigma[2], x0, N)
rw3.cpp <- rw_Metropolis(sigma[3], x0, N)
rw4.cpp <- rw_Metropolis(sigma[4], x0, N)

cat(" Accept rate: \n", 1-c(rw1.cpp$k /N, rw2.cpp$k /N, rw3.cpp$k /N, rw4.cpp$k /N))
```

Four chains are generated for different variances $\sigma^2$ of the proposal distribution. 

```{r, message=FALSE}
library(rmutil)                       # for qlaplace
refline <- qlaplace(c(.025, .975))    # target quantile value

par(mfrow=c(2,2))
plot(1:N, rw1.cpp$x, "l", xlab=expression(sigma==0.05), ylab="X")
abline(h=refline)
plot(1:N, rw2.cpp$x, "l", xlab=expression(sigma==0.5), ylab="X")
abline(h=refline)
plot(1:N, rw3.cpp$x, "l", xlab=expression(sigma==2), ylab="X")
abline(h=refline)
plot(1:N, rw4.cpp$x, "l", xlab=expression(sigma==16), ylab="X")
abline(h=refline)
```

In the first plot of Figure with $\sigma = 0.05$, the ratios $r(X_t,Y)$ tend to be large and almost every candidate point is accepted. 
The increments are small and the chain is almost like a true random walk. 
Chain 1 has not converged to the target in 2000 iterations. 
The chain in the second plot generated with $\sigma = 0.5$ is converging very slowly and requires a much longer burn-in period. 
In the third plot ($\sigma = 2$) the chain is mixing well and converging to the target distribution after a short burn-in period of about $500$. 
Finally, in the fourth plot, where $\sigma = 16$, the ratios $r(X_t,Y)$ are smaller and most of the candidate points are rejected. 
The fourth chain converges, but it is inefficient.

Usually in MCMC problems one does not have the theoretical quantiles of the target distribution available for comparison, but in this case the output
of the random walk Metropolis chains above can be compared with the theoretical quantiles of the target distribution. 
Discard the burn-in values in the first $500$ rows of each chain. 
The quantiles are computed by the **apply* function (applying quantile to the columns of the matrix). 
The quantiles of the target distribution and the sample quantiles of the four chains *rw1*, *rw2*, *rw3*, and *rw4* are in the following table.

```{r, warning=FALSE, message=FALSE}
library(rmutil)                           # for laplace distribution
a <- c(.05, seq(.1, .9, .1), .95)         # quantile points
Q <- qlaplace(a)                          # theritical quantiles
rw <- cbind(rw1.cpp$x, rw2.cpp$x, rw3.cpp$x, rw4.cpp$x)   
mc <- rw[501:N, ]
Qrw <- apply(mc, 2, function(x) quantile(x, a))  # calculate rw quantiles
# print(round(cbind(Q, Qrw), 3))          # for command line
# xtable::xtable(round(cbind(Q, Qrw), 3)) # latex format for pdf
kable(round(cbind(Q, rw1.cpp=Qrw[,1], rw2.cpp=Qrw[,2], rw3.cpp=Qrw[,3], rw4.cpp=Qrw[,4]), 3), caption="Quantiles of Target Distribution and Chines")
```


### Task 2 QQ plot
Compare the generated random numbers by the two functions using qqplot.
```{r}
# using r
rw1.r <- rw.Metropolis(sigma[1], x0, N)
rw2.r <- rw.Metropolis(sigma[2], x0, N)
rw3.r <- rw.Metropolis(sigma[3], x0, N)
rw4.r <- rw.Metropolis(sigma[4], x0, N)

# qqplot
par(mfrow=c(2,2))
qqplot(rw1.r$x, rw1.cpp$x, xlab="R", ylab="Rcpp")
abline(a=0,b=1, lty=2)
qqplot(rw2.r$x, rw2.cpp$x, xlab="R", ylab="Rcpp")
abline(a=0,b=1, lty=2)
qqplot(rw3.r$x, rw3.cpp$x, xlab="R", ylab="Rcpp")
abline(a=0,b=1, lty=2)
qqplot(rw4.r$x, rw4.cpp$x, xlab="R", ylab="Rcpp")
abline(a=0,b=1, lty=2)
```

The following is the qqplot using samples from R code only.
```{r}
qqplot(rw.Metropolis(sigma[1], x0, N)$x, rw.Metropolis(sigma[1], x0, N)$x, xlab="R", ylab="R")
abline(a=0,b=1, lty=2)
```

It shows that, when sigma is small, this method is not stable. 
So when $\sigma=2$, the qqplot shows that those two methods are similar, they have similar distribution. 

### Task 3 microbenchmark
```{r, warning=FALSE}
library(microbenchmark)
ts <- microbenchmark(rw.r=rw.Metropolis(2, x0, N), rw.cpp=rw_Metropolis(2, x0, N))
summary(ts)
```

### Task 4 Summmary

1. Rcpp's results are similar to those in R. 
We can know this by comparing the results of the first problem with the results of Exercise 9.4. 
Besides, QQ plot shows that the two methods from R and Rcpp are similar, when the $\sigma$ is appropriate. 

2. If you call the R function in Rcpp, it may become slower. 
We can find that the Rcpp method is slower, because we use the two R functions *rnorm* and *runif* in Rcpp. 
Cross calling will make the program's calculation time longer. 
Rcpp also needs to optimize the loop, otherwise the effect of R itself cannot be achieved.