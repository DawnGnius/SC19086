 
---
output:
  beamer_presentation: default
---

# High performance computation with Rcpp


* Outline

    + Why Cpp?
    
    + Prerequistes
        + Installation of c++ compiler and R packages
    
    + Cpp implementation 
        + cppFunction
        + sourceCpp
    
    + General description of Cpp function
    
    + Rcpp sugar and and STL
    
    + Case studies

    



----

## Why Rcpp?

*  C++ is easiest to use and has the best interface with R among low level languages C, FORTRAN, and C++.
* C++ is generally faster than R. Typical R bottlenecks that C++ can address include
* Loops that cannot be vectorized.
* Recursive functions, or problems which involve calling functions millions of times.
    + Problems that require advanced data structures and algorithms that R
doesnâ€™t provide.
* Reference: [\color{blue}Seamless R and C++ integration with Rcpp]() by Dirk Eddelbuettel

----

## Prerequistes

* Install R package [\color{blue}Rcpp]() (functions [\color{blue}cppFunction]() and [\color{blue}sourceCpp]()): 
    ```{r,eval=FALSE}
    install.packages('Rcpp')
    ```
* Install C++ compiler
    + Windows: install [\color{blue}Rtools]() from [\color{blue}http://cran.r-project.org/bin/windows/Rtools/]()
    + Linux (Ubuntu): [\color{blue}sudo apt-get install r-base-dev]().
    + Mac: install [\color{blue}Xcode]() (enter [\color{blue}xcode-select --install]() in *terminal*).

----

## Rcpp implementation

* Inline c++ with [\color{blue}cppFunction]()
    + C++ implementation of function [\color{blue}mean]()
    ```{r,eval=FALSE}
    library(Rcpp) # Attach R package "Rcpp"
    # Define function "add"
    cppFunction('int add(int x, int y, int z) {
      int sum = x + y + z;
      return sum;
    }')
    add(1,2,3) # call "add"
    ```
    + C++ code is placed between the single quotes [\underline{\color{red}' '}]().
    + With cppFunction, Rcpp will compile the C++ code (take some time) and construct an R function that connects to the compiled C++ function.
    
----


* Standalone C++ with [\color{blue}sourceCpp]()

    + C++ version of [\color{blue}mean]()(../Rcpp/meanC.cpp).

    ```{r}
    library(Rcpp)
    dir_cpp <- '../Rcpp/'
    # Can create source file in Rstudio
    sourceCpp(paste0(dir_cpp,"meanC.cpp")) 
    library(microbenchmark)
    x <- runif(1e4); mean2 <- function(x)sum(x)/length(x)
    ts <- microbenchmark(meanR=mean(x),meanR2=mean2(x),
                         meancpp=meanC(x))
    summary(ts)[,c(1,3,5,6)]
    ```
    
----

## Description of Cpp function

* General inputs and outputs in Rcpp
    + [\color{blue}Scalar](): int, double, string, bool
    + [\color{blue}Vector](): IntegerVector, NumericVector, CharacterVector, LogicalVector
    + [\color{blue}Matrix](): IntegerMatrix, NumericMatrix, CharacterMatrix, LogicalMatrix
    
* Special inputs and output in Rcpp
    + [\color{blue}Ouput](): List, DataFrame
    + [\color{blue}Input](): Function
    
----

* Example: [\underline{\color{blue}C++ version of lapply}](inputs: list and function)

```{r,eval=FALSE}
sourceCpp(paste0(dir_cpp,'lapplyC.cpp'))
m <- 1e3; n <- 100; dat <- vector("list", m);
for(i in 1:m){
  x <- cbind(rnorm(n),runif(n))
  y <- -1 + x[,1] + 0.5 * x[,2] + rnorm(n)
  dat[[i]] <- list(y=y,x=x)
}
lm1 <- function(z) summary(lm(z$y~z$x))$coef[1,]
t1 <- system.time(res1 <- lapply(dat,lm1))
t2 <- system.time(res2 <- lapplyC(dat,lm1))
```

```{r,eval=FALSE,eval=FALSE}
res <- rbind(t1,t2)
save(res,file='tmp.Rdata')
```

```{r,echo=FALSE}
load('tmp.Rdata')
knitr::kable(res,format='latex')
```

----

## Rcpp sugar and and STL

### Rcpp Sugar

* [\color{blue}Arithmatic and logical operations]{}: +, *, -, /, pow, <, <=, >, >=, ==, !=, !
* [\color{blue}Logical summary functions]{}: head(), tail(), rep_each(), rep_len(), rev(), seq_along(), seq_len()
* [\color{blue}Math functions]{}: abs(), acos(), asin(), atan(), beta(), ceil(), ceiling(), choose(), cos(), cosh(), digamma(), exp(), expm1(), factorial(), floor(), gamma(), lbeta(), lchoose(), lfactorial(), lgamma(), log(), log10(), log1p(), pentagamma(), psigamma(), round(), signif(), sin(), sinh(), sqrt(), tan(), tanh(), tetragamma(), trigamma(), trunc()

----


* [\color{blue}Scalar summaries]{}: mean(), min(), max(), sum(), sd(), and (for vectors)
var().
* [\color{blue}Vector summaries]{}: cumsum(), diff(), pmin(), and pmax().
* [\color{blue}Finding values]{}: match(), self_match(), which_max(), which_min().
* [\color{blue}Dealing with duplicates]{}: duplicated(), unique().
* [\color{blue}d/q/p/r]() for all standard distributions.
    
----

### Standard template library (STL) 

* Iterators (pointers in C++?) have three main operators
    + Advance with ++
    + Get the value they refer to, or dereference, with *.
    + Compare with ==.
    ```{r,eval=FALSE}
    #include <Rcpp.h>
    using namespace Rcpp;
    // [[Rcpp::export]]
    double sumC(NumericVector x) {
      double total = 0;
      
      NumericVector::iterator it;
      for(it = x.begin(); it != x.end(); ++it) {
        total += *it;
      }
      return total;
    }
    ```


----


* Data structure
    + A good reference of data structure: [\underline{\color{blue}http://www.cplusplus.com/reference/stl/}]{}. Keep it open while working with the STL. 
    + Available data structures: array, bitset, list, forward_list, map, multimap, multiset, priority_queue, queue, deque, set, stack, unordered_map, unordered_set, unordered_multimap, unordered_multiset, and vector.
    + Most important ones: vector, unordered_set, unordered_map.
    
    
----


* Data structure (continued)

    + STL vector: very similar to an R vector, except that it grows efficiently.
    [\underline{\color{blue}C++ version of `rle'}](../Rcpp/rleC.cpp). 
    ```{r}
    sourceCpp(paste0(dir_cpp,'rleC.cpp'))
    x <- rev(rep(6:10, 1:5))
    ts <- microbenchmark(rleR=rle(x), rleC=rleC(x))
    summary(ts)[,c(1,3,5,6)]
    ```

----


* Data structure (continued)
    + STL set: std::set (tree), std::unordered_set (harsh table). [\underline{\color{blue}C++ version of `duplicated'}](../Rcpp/duplicatedC.cpp).
    ```{r}
    sourceCpp(paste0(dir_cpp,'duplicatedC.cpp'))
    x <- sample(1:10,10,replace=TRUE)
    ts <- microbenchmark(duplicatedR=duplicated(x),
                         duplicatedC=duplicatedC(x))
    summary(ts)[,c(1,3,5,6)]
    ```


----


* Data structure (continued)
    + STL map: std::map; std::unordered_map (Rcpp::plugins(cpp11))
        
    ```{r}
    sourceCpp(paste0(dir_cpp,'tableC.cpp'))
    x <- sample(1:10,1e4,replace=TRUE)
    ts <- microbenchmark(tableR=table(x),tableC=tableC(x))
    summary(ts)[,c(1,3,5,6)]
    ```
    
    
----


## Case studies


* Gibbs sampler

    + [\underline{\color{blue}R code}](../Rcpp/gibbs.R) and [\underline{\color{blue}C++ code}](../Rcpp/gibbs.cpp) for Gibbs sampler.
    ```{r}
    source(paste0(dir_cpp,'gibbsR.R'))
    sourceCpp(paste0(dir_cpp,'gibbsC.cpp'))
    ts <- microbenchmark(gibbR=gibbsR(100,10), 
                         gibbC=gibbsC(100,10))
    summary(ts)[,c(1,3,5,6)]
    ```
    + Can be even faster using the [\color{blue}random number generators in GSL](http://dirk.eddelbuettel.com/blog/2011/07/14/). Need to insall GSL and R package RcppGSL on your computer.



----


* R vectorisation vs. C++ vectorisation


    + [\underline{\color{blue}R code}](../Rcpp/vaccR.R) and [\underline{\color{blue}C++ code}](../Rcpp/vaccC.cpp).

    ```{r}
    source(paste0(dir_cpp,'vaccR.R'))
    sourceCpp(paste0(dir_cpp,'vaccC.cpp'))
    n <- 1000; age <- rnorm(n, mean = 50, sd = 10)
    female <- sample(c(T, F), n, rep = TRUE)
    ily<-sample(c(T,F),n,prob=c(0.8,0.2),rep=TRUE)
    ts <- microbenchmark(
    vacc1 = vacc1(age, female, ily),
    vacc2 = vacc2(age, female, ily),
    vacc3 = vacc3(age, female, ily))
    summary(ts)[,c(1,3,5,6)]
    ```

  
